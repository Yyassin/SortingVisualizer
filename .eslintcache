[{"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\App.tsx":"1","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\reportWebVitals.ts":"2","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\SortingVisualizer.tsx":"3","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\NavItems.tsx":"4","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\index.tsx":"5","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\NavBar.tsx":"6","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\bubbleSort.ts":"7","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\Burger.tsx":"8","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\Footer.tsx":"9","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\styles.ts":"10","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\quickSort.ts":"11","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\heapSort.ts":"12","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\utils\\animationUtils.ts":"13","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\utils\\algoUtils.ts":"14","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\insertionSort.ts":"15","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\selectionSort.ts":"16","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\mergeSort.ts":"17"},{"size":403,"mtime":1609278639734,"results":"18","hashOfConfig":"19"},{"size":425,"mtime":1609282376304,"results":"20","hashOfConfig":"19"},{"size":7351,"mtime":1609282884038,"results":"21","hashOfConfig":"19"},{"size":1163,"mtime":1609281967566,"results":"22","hashOfConfig":"19"},{"size":500,"mtime":1609257318014,"results":"23","hashOfConfig":"19"},{"size":3036,"mtime":1609281968794,"results":"24","hashOfConfig":"19"},{"size":1623,"mtime":1609278646015,"results":"25","hashOfConfig":"19"},{"size":1072,"mtime":1609281967566,"results":"26","hashOfConfig":"19"},{"size":699,"mtime":1609278753075,"results":"27","hashOfConfig":"19"},{"size":4523,"mtime":1609281967444,"results":"28","hashOfConfig":"19"},{"size":2063,"mtime":1609278552245,"results":"29","hashOfConfig":"19"},{"size":2219,"mtime":1609281776058,"results":"30","hashOfConfig":"19"},{"size":2291,"mtime":1609278333827,"results":"31","hashOfConfig":"19"},{"size":243,"mtime":1609278628224,"results":"32","hashOfConfig":"19"},{"size":990,"mtime":1609278664029,"results":"33","hashOfConfig":"19"},{"size":1289,"mtime":1609278570626,"results":"34","hashOfConfig":"19"},{"size":2189,"mtime":1609278887830,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"14ugsr6",{"filePath":"38","messages":"39","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"41"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"48"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"60","messages":"61","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62","usedDeprecatedRules":"48"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"65","usedDeprecatedRules":"48"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"71","messages":"72","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73","usedDeprecatedRules":"48"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78","usedDeprecatedRules":"48"},"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\App.tsx",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\reportWebVitals.ts",["79"],"import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\SortingVisualizer.tsx",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\NavItems.tsx",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\index.tsx",[],[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\NavBar.tsx",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\bubbleSort.ts",["80"],"import { swap } from '../utils/algoUtils';\r\n\r\nexport const bubbleSortHelper = (arr: number[]) : number[] => {\r\n    const animations = [];\r\n    bubbleSort(arr, animations);\r\n    return animations;\r\n}\r\n\r\n/*\r\nIteratively sort array by swapping any pairs where the first \r\nadjacent element is larger than the second. Walk through the \r\narray until no swaps occur -> sorted.\r\n*/\r\nconst bubbleSort = (arr: number[], animations: any[]) : void => {\r\n    let sorted = false;\r\n    let round = 0;\r\n    let finalSorted: number;\r\n    const length = arr.length;\r\n\r\n    while (!sorted) {\r\n        sorted = true;\r\n        for (let i = 0; i < length - 1- round; i++) {\r\n            if (arr[i] > arr[i + 1]) {\r\n                animations.push([i, i + 1, true]);\r\n                i === arr.length - 2 - round ? animations.push([i, i + 1, 'f']) : animations.push([i, i + 1])\r\n                animations.push([i, arr[i + 1], i + 1, arr[i]]);\r\n                \r\n                sorted = false;\r\n                swap(arr, i, i + 1);\r\n            } else {\r\n                animations.push([i, i + 1, false]);\r\n\r\n                if (i === length - 2 - round) {\r\n                    animations.push([i, i + 1, 'f'])\r\n                    finalSorted = i + 1;\r\n                } else {\r\n                    animations.push([i, i + 1])\r\n                }\r\n                animations.push([i, arr[i], i + 1, arr[i + 1]])\r\n            }\r\n        }\r\n        round++;\r\n    }\r\n    for (let j = finalSorted; j >= 0; j--) {\r\n        animations.push([j, j, 'f'])\r\n        animations.push([j, j, 'f'])\r\n        animations.push([j, arr[j], j, arr[j]])\r\n    } \r\n}","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\Burger.tsx",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\Footer.tsx",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\styles.ts",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\quickSort.ts",["81","82"],"import { swap } from \"../utils/algoUtils\";\r\n\r\nexport const quickSortHelper = (arr: number[]) : number[] => {\r\n    const animations = [];\r\n    quickSort(arr, 0, arr.length - 1, animations);\r\n    return animations;\r\n}\r\n\r\n/*\r\nConsider final index in segment as pivot. Partition the segment\r\naround this pivot, swapping elements and returning the index\r\nsuch that the partitioned element is in its sorted position: i.e \r\ngreater than all left indices and less than all right indices.\r\n*/\r\nconst partition = (arr: number[], low: number, high: number, animations: any[]): number => {\r\n    const pivotVal = arr[high];\r\n    let pivotIdx = low;\r\n    \r\n    //Pivot index always points to sorted position so far.\r\n    //If i < pivot value, then we increment the pivot index and swap i \r\n    //with the index's former value since it may be larger (if not equal).\r\n    for (let i = low; i < high; i++) {\r\n        if (arr[i] < pivotVal) {\r\n            animations.push([i, high, true])\r\n            animations.push([i, high])\r\n\r\n            animations.push([i, arr[pivotIdx], pivotIdx, arr[i]]);\r\n\r\n            [arr[i], arr[pivotIdx]] = [arr[pivotIdx], arr[i]];\r\n            pivotIdx++;\r\n            \r\n        } else {\r\n            animations.push([i, high, false])\r\n            animations.push([i, high])\r\n\r\n            animations.push([i, arr[i], pivotIdx, arr[pivotIdx]]);\r\n        }\r\n    }    \r\n\r\n    //Move the pivot in its sorted position.\r\n    animations.push([pivotIdx, pivotIdx, 'f'])\r\n    animations.push([pivotIdx, arr[high], high, arr[pivotIdx]]);\r\n\r\n    swap(arr, pivotIdx, high);\r\n    return pivotIdx;\r\n}\r\n\r\n/*\r\nRecursively sort array by choosing pivot and placing it in its sorted position.\r\nCall quicksort on the resulting two sub-arrays.\r\n*/\r\nconst quickSort = (arr: number[], low: number, high: number, animations: any[]): void => {\r\n    if (low >= high) {\r\n        return;\r\n    }\r\n\r\n        const pivot = partition(arr, low, high, animations);\r\n        quickSort(arr, low, pivot - 1, animations);\r\n        quickSort(arr, pivot + 1, high, animations);\r\n}\r\n\r\n\r\n","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\heapSort.ts",["83","84"],"import { swap } from '../utils/algoUtils';\r\n\r\nexport const heapSortHelper = (arr: number[]) : number[] => {\r\n    const animations = [];\r\n    heapSort(arr, animations);\r\n    return animations;\r\n}\r\n\r\n/* \r\nRecursive method to insert nodes into max heap\r\narr: array, \r\nn: total nodes, \r\ni: current node being considered as max (root)\r\nanimations: animations array\r\n*/\r\nconst heapify = (arr: number[], n: number, i: number, animations: any[]): void => {\r\n    /*\r\n    For a zero-indexed array rep. of max heap:\r\n    parent @ Math.floor((i - 1) / 2)\r\n    left child @ 2i + 1\r\n    right child @ 2i + 2\r\n    */\r\n\r\n    let largest = i;\r\n    const left = 2 * i + 1,\r\n    right = 2 * i + 2;\r\n\r\n    //left child was larger\r\n    if (left < n && arr[left] > arr[largest]) {\r\n        animations.push([left, largest, true])\r\n        animations.push([left, largest])\r\n        largest = left;\r\n    }\r\n\r\n    //right child was larger\r\n    if (right < n && arr[right] > arr[largest]) {\r\n        animations.push([right, largest, true])\r\n        animations.push([right, largest])\r\n        largest = right;\r\n    }\r\n\r\n    //if swapped, recursively call heapify on child node\r\n    if (largest !== i) {\r\n        animations.push([i, largest, false])\r\n        animations.push([i, largest])\r\n        animations.push([i, arr[largest], largest, arr[i]])\r\n        animations.push([i, largest])\r\n        swap(arr, i, largest);\r\n        heapify(arr, n, largest, animations)\r\n    }\r\n}\r\n\r\n/*\r\nRecursively sort array by extracting max heap root.\r\nStore it at the end of the array and heapify the remaining array, repeat.\r\n*/\r\nconst heapSort = (arr: number[], animations: any[]): void => {\r\n    //rearrange array into heap structure\r\n    const start = Math.floor(arr.length / 2) - 1;\r\n\r\n    for (let i = start; i >= 0; i--) {\r\n        heapify(arr, arr.length, i, animations)\r\n    }\r\n\r\n    //extract n roots, and heapify new root (former last index)\r\n    for (let i = arr.length - 1; i >= 0; i-- ) {\r\n        animations.push([0, arr[i], i, arr[0]])\r\n        animations.push([0, i, true])\r\n        const temp = arr[0];\r\n        arr[0] = arr[i];\r\n        arr[i] = temp\r\n        heapify(arr, i, 0, animations); // size is one less as we remove nodes\r\n    }\r\n}\r\n\r\n","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\utils\\animationUtils.ts",["85","86","87"],"import { bubbleSortHelper } from '../algorithms/bubbleSort';\r\nimport { insertionSortHelper } from '../algorithms/insertionSort';\r\nimport { selectionSortHelper } from '../algorithms/selectionSort';\r\nimport { quickSortHelper } from '../algorithms/quickSort';\r\nimport { mergeSortHelper } from '../algorithms/mergeSort';\r\nimport { heapSortHelper } from '../algorithms/heapSort';\r\n\r\nexport const animationsHelper = (key: string, array: number[]): any[] => {\r\n    switch (key) {\r\n        case 'b':\r\n            return bubbleSortHelper(array);\r\n        case 'i':\r\n            return insertionSortHelper(array);\r\n        case 's':\r\n            return selectionSortHelper(array);\r\n        case 'q':\r\n            return quickSortHelper(array);\r\n        case 'm':\r\n            return mergeSortHelper(array);\r\n        case 'h':\r\n            return heapSortHelper(array);\r\n        default:\r\n            break;\r\n    }\r\n};\r\n\r\nexport const colorChangeHelper = (key: string, animations: any[], i: number): boolean => {\r\n    if (['b', 'm', 'i'].includes(key)) {\r\n        return i % 3 !== 2;\r\n    } else {\r\n        return animations[i].length < 4;\r\n    }\r\n};\r\n\r\nexport const colorHelper = (key: string, animations: any[], i: number): string[] => {\r\n    let color = '#b08ffc',\r\n        color2 = null;\r\n\r\n    if (['b', 'm', 'i'].includes(key)) {\r\n        if (i % 3 === 0) {\r\n            if (animations[i][2]) {\r\n                key === 'm' ? (color = '#6A75AE') : (color = 'red');\r\n            } else {\r\n                color = 'green';\r\n            }\r\n        } else if (animations[i][2] === 'f' && key != 'i') {\r\n            color2 = '#6A75AE';\r\n        }\r\n    } else if (['h', 's'].includes(key)) {\r\n        if (i % 2 === 0) {\r\n            if (animations[i][2]) {\r\n                color = 'red';\r\n            } else {\r\n                color = 'green';\r\n            }\r\n        } else if (animations[i][2]) {\r\n            color = '#6A75AE';\r\n        }\r\n    } else {\r\n        //quicksort\r\n        if (animations[i].length === 3) {\r\n            if (animations[i][2] === 'f') {\r\n                color2 = '#6A75AE';\r\n            } else if (animations[i][2]) {\r\n                color = 'red';\r\n            } else {\r\n                color = 'green';\r\n            }\r\n        }\r\n    }\r\n\r\n    return [color, color2];\r\n};","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\utils\\algoUtils.ts",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\insertionSort.ts",["88"],"export const insertionSortHelper = (arr: number[]): number[] => {\r\n    const animations = [];\r\n    insertionSort(arr, animations);\r\n    return animations;\r\n}\r\n\r\n/*\r\nSort array by walking through each element and inserting it\r\nin its place in the so-far sorted array behind it by shifting\r\nthe corresponding elements forward.\r\n*/\r\nconst insertionSort = (arr: number[], animations: any[]): void => {\r\n    for (let i = 0; i < arr.length; i++) {\r\n        const key = arr[i];\r\n        let j = i - 1;\r\n\r\n        //shift current index back until\r\n        //the index ahead of it is greater, hence in so-far sorted position.\r\n        while (j >= 0 && key < arr[j]) {\r\n            animations.push([j, i, false]);\r\n            animations.push([j, i]);\r\n            animations.push([j + 1, arr[j]]);\r\n            arr[j + 1] = arr[j--];\r\n        }\r\n\r\n        animations.push([i, i, true]);\r\n        animations.push([i, i]);\r\n        animations.push([j + 1, key]);\r\n        arr[j + 1] = key;\r\n    }\r\n}\r\n","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\selectionSort.ts",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\mergeSort.ts",["89","90"],"export const mergeSortHelper = (arr: number[]): number[] => {\r\n    const aux = [...arr];\r\n    const animations = [];\r\n    mergeSort(arr, aux, 0, arr.length - 1, animations);\r\n    return animations;\r\n}\r\n\r\n/*\r\nMerge implementation using auxiliary array to maintain indices.\r\nMerges array1: low->mid, array2: mid+1->high.\r\nStore merge results in auxiliary array then copy to original array.\r\n*/\r\nconst merge = (arr: number[], aux: number[], low: number, \r\n    mid: number, high: number, animations: any[]): void => {\r\n    let k = low, \r\n        i = low,\r\n        j = mid + 1;\r\n\r\n    const finalMerge = 2 * (j - k) >= arr.length;\r\n\r\n        //Merge the two halves, storing results in auxiliary.\r\n        while (i <= mid && j <= high) {\r\n            animations.push([i, j])\r\n            finalMerge ? animations.push([i, j, 'f']) : animations.push([i, j])\r\n    \r\n            if (arr[i] <= arr[j]) {\r\n                animations.push([k, arr[i]]);\r\n                aux[k++] = arr[i++];\r\n            } else {\r\n                animations.push([k, arr[j]]);\r\n                aux[k++] = arr[j++];\r\n            }\r\n        }\r\n     \r\n        //Complete merging first half incase the second completes\r\n        //first. Second is already in place if first half completes\r\n        //first.\r\n        while(i <= mid) {\r\n            animations.push([k, i])\r\n            animations.push([k, i])\r\n            animations.push([k, arr[i]])\r\n            aux[k++] = arr[i++];\r\n        }\r\n\r\n        //Copy merge result back into original array.\r\n        for (let i = low; i <= high; i++) {\r\n            arr[i] = aux[i];\r\n        }\r\n}\r\n\r\n/*\r\nRecursively sort array by halving until reaching until cells. \r\nMerge and sort 'adjacent' unit cells to rebuild the sorted array.\r\n*/\r\nconst mergeSort = (arr: number[], aux: number[], low: number,\r\n    high: number, animations: any[]): void => {\r\n    if (low >= high) {\r\n        return;\r\n    }\r\n\r\n    const mid = Math.floor( low + (high - low) / 2);\r\n\r\n    //Merge sort on lower and upper halves.\r\n    mergeSort(arr, aux, low, mid, animations);\r\n    mergeSort(arr, aux, mid + 1, high, animations);\r\n\r\n    //Merge the result\r\n    merge(arr, aux, low, mid, high, animations);\r\n}",{"ruleId":"91","severity":1,"message":"92","line":3,"column":25,"nodeType":"93","messageId":"94","endLine":3,"endColumn":57},{"ruleId":"95","severity":1,"message":"96","line":14,"column":48,"nodeType":"97","messageId":"98","endLine":14,"endColumn":51,"suggestions":"99"},{"ruleId":"95","severity":1,"message":"96","line":15,"column":74,"nodeType":"97","messageId":"98","endLine":15,"endColumn":77,"suggestions":"100"},{"ruleId":"95","severity":1,"message":"96","line":52,"column":74,"nodeType":"97","messageId":"98","endLine":52,"endColumn":77,"suggestions":"101"},{"ruleId":"95","severity":1,"message":"96","line":16,"column":67,"nodeType":"97","messageId":"98","endLine":16,"endColumn":70,"suggestions":"102"},{"ruleId":"95","severity":1,"message":"96","line":57,"column":46,"nodeType":"97","messageId":"98","endLine":57,"endColumn":49,"suggestions":"103"},{"ruleId":"95","severity":1,"message":"96","line":8,"column":65,"nodeType":"97","messageId":"98","endLine":8,"endColumn":68,"suggestions":"104"},{"ruleId":"95","severity":1,"message":"96","line":27,"column":60,"nodeType":"97","messageId":"98","endLine":27,"endColumn":63,"suggestions":"105"},{"ruleId":"95","severity":1,"message":"96","line":35,"column":54,"nodeType":"97","messageId":"98","endLine":35,"endColumn":57,"suggestions":"106"},{"ruleId":"95","severity":1,"message":"96","line":12,"column":51,"nodeType":"97","messageId":"98","endLine":12,"endColumn":54,"suggestions":"107"},{"ruleId":"95","severity":1,"message":"96","line":14,"column":44,"nodeType":"97","messageId":"98","endLine":14,"endColumn":47,"suggestions":"108"},{"ruleId":"95","severity":1,"message":"96","line":56,"column":31,"nodeType":"97","messageId":"98","endLine":56,"endColumn":34,"suggestions":"109"},"@typescript-eslint/explicit-module-boundary-types","Missing return type on function.","ArrowFunctionExpression","missingReturnType","@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["110","111"],["112","113"],["114","115"],["116","117"],["118","119"],["120","121"],["122","123"],["124","125"],["126","127"],["128","129"],["130","131"],{"messageId":"132","fix":"133","desc":"134"},{"messageId":"135","fix":"136","desc":"137"},{"messageId":"132","fix":"138","desc":"134"},{"messageId":"135","fix":"139","desc":"137"},{"messageId":"132","fix":"140","desc":"134"},{"messageId":"135","fix":"141","desc":"137"},{"messageId":"132","fix":"142","desc":"134"},{"messageId":"135","fix":"143","desc":"137"},{"messageId":"132","fix":"144","desc":"134"},{"messageId":"135","fix":"145","desc":"137"},{"messageId":"132","fix":"146","desc":"134"},{"messageId":"135","fix":"147","desc":"137"},{"messageId":"132","fix":"148","desc":"134"},{"messageId":"135","fix":"149","desc":"137"},{"messageId":"132","fix":"150","desc":"134"},{"messageId":"135","fix":"151","desc":"137"},{"messageId":"132","fix":"152","desc":"134"},{"messageId":"135","fix":"153","desc":"137"},{"messageId":"132","fix":"154","desc":"134"},{"messageId":"135","fix":"155","desc":"137"},{"messageId":"132","fix":"156","desc":"134"},{"messageId":"135","fix":"157","desc":"137"},"suggestUnknown",{"range":"158","text":"159"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"158","text":"160"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"161","text":"159"},{"range":"161","text":"160"},{"range":"162","text":"159"},{"range":"162","text":"160"},{"range":"163","text":"159"},{"range":"163","text":"160"},{"range":"164","text":"159"},{"range":"164","text":"160"},{"range":"165","text":"159"},{"range":"165","text":"160"},{"range":"166","text":"159"},{"range":"166","text":"160"},{"range":"167","text":"159"},{"range":"167","text":"160"},{"range":"168","text":"159"},{"range":"168","text":"160"},{"range":"169","text":"159"},{"range":"169","text":"160"},{"range":"170","text":"159"},{"range":"170","text":"160"},[422,425],"unknown","never",[558,561],[1818,1821],[431,434],[1632,1635],[442,445],[970,973],[1196,1199],[380,383],[496,499],[1841,1844]]