[{"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\App.tsx":"1","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\reportWebVitals.ts":"2","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\SortingVisualizer.tsx":"3","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\NavItems.tsx":"4","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\index.tsx":"5","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\NavBar.tsx":"6","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\bubbleSort.ts":"7","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\Burger.tsx":"8","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\Footer.tsx":"9","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\styles.ts":"10","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\quickSort.ts":"11","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\heapSort.ts":"12","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\utils\\animationUtils.ts":"13","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\utils\\algoUtils.ts":"14","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\insertionSort.ts":"15","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\selectionSort.ts":"16","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\mergeSort.ts":"17"},{"size":403,"mtime":1609278639734,"results":"18","hashOfConfig":"19"},{"size":425,"mtime":1609282376304,"results":"20","hashOfConfig":"19"},{"size":7351,"mtime":1609282884038,"results":"21","hashOfConfig":"19"},{"size":1163,"mtime":1609281967566,"results":"22","hashOfConfig":"19"},{"size":500,"mtime":1609257318014,"results":"23","hashOfConfig":"19"},{"size":3036,"mtime":1609281968794,"results":"24","hashOfConfig":"19"},{"size":1623,"mtime":1609278646015,"results":"25","hashOfConfig":"19"},{"size":1072,"mtime":1609281967566,"results":"26","hashOfConfig":"19"},{"size":699,"mtime":1609278753075,"results":"27","hashOfConfig":"19"},{"size":4523,"mtime":1609281967444,"results":"28","hashOfConfig":"19"},{"size":2063,"mtime":1609278552245,"results":"29","hashOfConfig":"19"},{"size":2219,"mtime":1609281776058,"results":"30","hashOfConfig":"19"},{"size":2291,"mtime":1609278333827,"results":"31","hashOfConfig":"19"},{"size":243,"mtime":1609278628224,"results":"32","hashOfConfig":"19"},{"size":990,"mtime":1609278664029,"results":"33","hashOfConfig":"19"},{"size":1289,"mtime":1609278570626,"results":"34","hashOfConfig":"19"},{"size":2189,"mtime":1609278887830,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"14ugsr6",{"filePath":"38","messages":"39","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"46"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"46"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70","usedDeprecatedRules":"46"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"75","usedDeprecatedRules":"46"},"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\App.tsx",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\reportWebVitals.ts",["76"],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\SortingVisualizer.tsx",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\NavItems.tsx",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\index.tsx",[],[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\NavBar.tsx",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\bubbleSort.ts",["77"],"import { swap } from '../utils/algoUtils';\r\n\r\nexport const bubbleSortHelper = (arr: number[]) : number[] => {\r\n    const animations = [];\r\n    bubbleSort(arr, animations);\r\n    return animations;\r\n}\r\n\r\n/*\r\nIteratively sort array by swapping any pairs where the first \r\nadjacent element is larger than the second. Walk through the \r\narray until no swaps occur -> sorted.\r\n*/\r\nconst bubbleSort = (arr: number[], animations: any[]) : void => {\r\n    let sorted = false;\r\n    let round = 0;\r\n    let finalSorted: number;\r\n    const length = arr.length;\r\n\r\n    while (!sorted) {\r\n        sorted = true;\r\n        for (let i = 0; i < length - 1- round; i++) {\r\n            if (arr[i] > arr[i + 1]) {\r\n                animations.push([i, i + 1, true]);\r\n                i === arr.length - 2 - round ? animations.push([i, i + 1, 'f']) : animations.push([i, i + 1])\r\n                animations.push([i, arr[i + 1], i + 1, arr[i]]);\r\n                \r\n                sorted = false;\r\n                swap(arr, i, i + 1);\r\n            } else {\r\n                animations.push([i, i + 1, false]);\r\n\r\n                if (i === length - 2 - round) {\r\n                    animations.push([i, i + 1, 'f'])\r\n                    finalSorted = i + 1;\r\n                } else {\r\n                    animations.push([i, i + 1])\r\n                }\r\n                animations.push([i, arr[i], i + 1, arr[i + 1]])\r\n            }\r\n        }\r\n        round++;\r\n    }\r\n    for (let j = finalSorted; j >= 0; j--) {\r\n        animations.push([j, j, 'f'])\r\n        animations.push([j, j, 'f'])\r\n        animations.push([j, arr[j], j, arr[j]])\r\n    } \r\n}","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\Burger.tsx",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\Footer.tsx",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\components\\styles.ts",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\quickSort.ts",["78","79"],"import { swap } from \"../utils/algoUtils\";\r\n\r\nexport const quickSortHelper = (arr: number[]) : number[] => {\r\n    const animations = [];\r\n    quickSort(arr, 0, arr.length - 1, animations);\r\n    return animations;\r\n}\r\n\r\n/*\r\nConsider final index in segment as pivot. Partition the segment\r\naround this pivot, swapping elements and returning the index\r\nsuch that the partitioned element is in its sorted position: i.e \r\ngreater than all left indices and less than all right indices.\r\n*/\r\nconst partition = (arr: number[], low: number, high: number, animations: any[]): number => {\r\n    const pivotVal = arr[high];\r\n    let pivotIdx = low;\r\n    \r\n    //Pivot index always points to sorted position so far.\r\n    //If i < pivot value, then we increment the pivot index and swap i \r\n    //with the index's former value since it may be larger (if not equal).\r\n    for (let i = low; i < high; i++) {\r\n        if (arr[i] < pivotVal) {\r\n            animations.push([i, high, true])\r\n            animations.push([i, high])\r\n\r\n            animations.push([i, arr[pivotIdx], pivotIdx, arr[i]]);\r\n\r\n            [arr[i], arr[pivotIdx]] = [arr[pivotIdx], arr[i]];\r\n            pivotIdx++;\r\n            \r\n        } else {\r\n            animations.push([i, high, false])\r\n            animations.push([i, high])\r\n\r\n            animations.push([i, arr[i], pivotIdx, arr[pivotIdx]]);\r\n        }\r\n    }    \r\n\r\n    //Move the pivot in its sorted position.\r\n    animations.push([pivotIdx, pivotIdx, 'f'])\r\n    animations.push([pivotIdx, arr[high], high, arr[pivotIdx]]);\r\n\r\n    swap(arr, pivotIdx, high);\r\n    return pivotIdx;\r\n}\r\n\r\n/*\r\nRecursively sort array by choosing pivot and placing it in its sorted position.\r\nCall quicksort on the resulting two sub-arrays.\r\n*/\r\nconst quickSort = (arr: number[], low: number, high: number, animations: any[]): void => {\r\n    if (low >= high) {\r\n        return;\r\n    }\r\n\r\n        const pivot = partition(arr, low, high, animations);\r\n        quickSort(arr, low, pivot - 1, animations);\r\n        quickSort(arr, pivot + 1, high, animations);\r\n}\r\n\r\n\r\n","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\heapSort.ts",["80","81"],"import { swap } from '../utils/algoUtils';\r\n\r\nexport const heapSortHelper = (arr: number[]) : number[] => {\r\n    const animations = [];\r\n    heapSort(arr, animations);\r\n    return animations;\r\n}\r\n\r\n/* \r\nRecursive method to insert nodes into max heap\r\narr: array, \r\nn: total nodes, \r\ni: current node being considered as max (root)\r\nanimations: animations array\r\n*/\r\nconst heapify = (arr: number[], n: number, i: number, animations: any[]): void => {\r\n    /*\r\n    For a zero-indexed array rep. of max heap:\r\n    parent @ Math.floor((i - 1) / 2)\r\n    left child @ 2i + 1\r\n    right child @ 2i + 2\r\n    */\r\n\r\n    let largest = i;\r\n    const left = 2 * i + 1,\r\n    right = 2 * i + 2;\r\n\r\n    //left child was larger\r\n    if (left < n && arr[left] > arr[largest]) {\r\n        animations.push([left, largest, true])\r\n        animations.push([left, largest])\r\n        largest = left;\r\n    }\r\n\r\n    //right child was larger\r\n    if (right < n && arr[right] > arr[largest]) {\r\n        animations.push([right, largest, true])\r\n        animations.push([right, largest])\r\n        largest = right;\r\n    }\r\n\r\n    //if swapped, recursively call heapify on child node\r\n    if (largest !== i) {\r\n        animations.push([i, largest, false])\r\n        animations.push([i, largest])\r\n        animations.push([i, arr[largest], largest, arr[i]])\r\n        animations.push([i, largest])\r\n        swap(arr, i, largest);\r\n        heapify(arr, n, largest, animations)\r\n    }\r\n}\r\n\r\n/*\r\nRecursively sort array by extracting max heap root.\r\nStore it at the end of the array and heapify the remaining array, repeat.\r\n*/\r\nconst heapSort = (arr: number[], animations: any[]): void => {\r\n    //rearrange array into heap structure\r\n    const start = Math.floor(arr.length / 2) - 1;\r\n\r\n    for (let i = start; i >= 0; i--) {\r\n        heapify(arr, arr.length, i, animations)\r\n    }\r\n\r\n    //extract n roots, and heapify new root (former last index)\r\n    for (let i = arr.length - 1; i >= 0; i-- ) {\r\n        animations.push([0, arr[i], i, arr[0]])\r\n        animations.push([0, i, true])\r\n        const temp = arr[0];\r\n        arr[0] = arr[i];\r\n        arr[i] = temp\r\n        heapify(arr, i, 0, animations); // size is one less as we remove nodes\r\n    }\r\n}\r\n\r\n","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\utils\\animationUtils.ts",["82","83","84"],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\utils\\algoUtils.ts",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\insertionSort.ts",["85"],"export const insertionSortHelper = (arr: number[]): number[] => {\r\n    const animations = [];\r\n    insertionSort(arr, animations);\r\n    return animations;\r\n}\r\n\r\n/*\r\nSort array by walking through each element and inserting it\r\nin its place in the so-far sorted array behind it by shifting\r\nthe corresponding elements forward.\r\n*/\r\nconst insertionSort = (arr: number[], animations: any[]): void => {\r\n    for (let i = 0; i < arr.length; i++) {\r\n        const key = arr[i];\r\n        let j = i - 1;\r\n\r\n        //shift current index back until\r\n        //the index ahead of it is greater, hence in so-far sorted position.\r\n        while (j >= 0 && key < arr[j]) {\r\n            animations.push([j, i, false]);\r\n            animations.push([j, i]);\r\n            animations.push([j + 1, arr[j]]);\r\n            arr[j + 1] = arr[j--];\r\n        }\r\n\r\n        animations.push([i, i, true]);\r\n        animations.push([i, i]);\r\n        animations.push([j + 1, key]);\r\n        arr[j + 1] = key;\r\n    }\r\n}\r\n","C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\selectionSort.ts",[],"C:\\Users\\Game-PC\\Desktop\\vis-ts\\sorting_visualizer\\src\\algorithms\\mergeSort.ts",["86","87"],"export const mergeSortHelper = (arr: number[]): number[] => {\r\n    const aux = [...arr];\r\n    const animations = [];\r\n    mergeSort(arr, aux, 0, arr.length - 1, animations);\r\n    return animations;\r\n}\r\n\r\n/*\r\nMerge implementation using auxiliary array to maintain indices.\r\nMerges array1: low->mid, array2: mid+1->high.\r\nStore merge results in auxiliary array then copy to original array.\r\n*/\r\nconst merge = (arr: number[], aux: number[], low: number, \r\n    mid: number, high: number, animations: any[]): void => {\r\n    let k = low, \r\n        i = low,\r\n        j = mid + 1;\r\n\r\n    const finalMerge = 2 * (j - k) >= arr.length;\r\n\r\n        //Merge the two halves, storing results in auxiliary.\r\n        while (i <= mid && j <= high) {\r\n            animations.push([i, j])\r\n            finalMerge ? animations.push([i, j, 'f']) : animations.push([i, j])\r\n    \r\n            if (arr[i] <= arr[j]) {\r\n                animations.push([k, arr[i]]);\r\n                aux[k++] = arr[i++];\r\n            } else {\r\n                animations.push([k, arr[j]]);\r\n                aux[k++] = arr[j++];\r\n            }\r\n        }\r\n     \r\n        //Complete merging first half incase the second completes\r\n        //first. Second is already in place if first half completes\r\n        //first.\r\n        while(i <= mid) {\r\n            animations.push([k, i])\r\n            animations.push([k, i])\r\n            animations.push([k, arr[i]])\r\n            aux[k++] = arr[i++];\r\n        }\r\n\r\n        //Copy merge result back into original array.\r\n        for (let i = low; i <= high; i++) {\r\n            arr[i] = aux[i];\r\n        }\r\n}\r\n\r\n/*\r\nRecursively sort array by halving until reaching until cells. \r\nMerge and sort 'adjacent' unit cells to rebuild the sorted array.\r\n*/\r\nconst mergeSort = (arr: number[], aux: number[], low: number,\r\n    high: number, animations: any[]): void => {\r\n    if (low >= high) {\r\n        return;\r\n    }\r\n\r\n    const mid = Math.floor( low + (high - low) / 2);\r\n\r\n    //Merge sort on lower and upper halves.\r\n    mergeSort(arr, aux, low, mid, animations);\r\n    mergeSort(arr, aux, mid + 1, high, animations);\r\n\r\n    //Merge the result\r\n    merge(arr, aux, low, mid, high, animations);\r\n}",{"ruleId":"88","severity":1,"message":"89","line":3,"column":25,"nodeType":"90","messageId":"91","endLine":3,"endColumn":57},{"ruleId":"92","severity":1,"message":"93","line":14,"column":48,"nodeType":"94","messageId":"95","endLine":14,"endColumn":51,"suggestions":"96"},{"ruleId":"92","severity":1,"message":"93","line":15,"column":74,"nodeType":"94","messageId":"95","endLine":15,"endColumn":77,"suggestions":"97"},{"ruleId":"92","severity":1,"message":"93","line":52,"column":74,"nodeType":"94","messageId":"95","endLine":52,"endColumn":77,"suggestions":"98"},{"ruleId":"92","severity":1,"message":"93","line":16,"column":67,"nodeType":"94","messageId":"95","endLine":16,"endColumn":70,"suggestions":"99"},{"ruleId":"92","severity":1,"message":"93","line":57,"column":46,"nodeType":"94","messageId":"95","endLine":57,"endColumn":49,"suggestions":"100"},{"ruleId":"92","severity":1,"message":"93","line":8,"column":65,"nodeType":"94","messageId":"95","endLine":8,"endColumn":68,"suggestions":"101"},{"ruleId":"92","severity":1,"message":"93","line":27,"column":60,"nodeType":"94","messageId":"95","endLine":27,"endColumn":63,"suggestions":"102"},{"ruleId":"92","severity":1,"message":"93","line":35,"column":54,"nodeType":"94","messageId":"95","endLine":35,"endColumn":57,"suggestions":"103"},{"ruleId":"92","severity":1,"message":"93","line":12,"column":51,"nodeType":"94","messageId":"95","endLine":12,"endColumn":54,"suggestions":"104"},{"ruleId":"92","severity":1,"message":"93","line":14,"column":44,"nodeType":"94","messageId":"95","endLine":14,"endColumn":47,"suggestions":"105"},{"ruleId":"92","severity":1,"message":"93","line":56,"column":31,"nodeType":"94","messageId":"95","endLine":56,"endColumn":34,"suggestions":"106"},"@typescript-eslint/explicit-module-boundary-types","Missing return type on function.","ArrowFunctionExpression","missingReturnType","@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["107","108"],["109","110"],["111","112"],["113","114"],["115","116"],["117","118"],["119","120"],["121","122"],["123","124"],["125","126"],["127","128"],{"messageId":"129","fix":"130","desc":"131"},{"messageId":"132","fix":"133","desc":"134"},{"messageId":"129","fix":"135","desc":"131"},{"messageId":"132","fix":"136","desc":"134"},{"messageId":"129","fix":"137","desc":"131"},{"messageId":"132","fix":"138","desc":"134"},{"messageId":"129","fix":"139","desc":"131"},{"messageId":"132","fix":"140","desc":"134"},{"messageId":"129","fix":"141","desc":"131"},{"messageId":"132","fix":"142","desc":"134"},{"messageId":"129","fix":"143","desc":"131"},{"messageId":"132","fix":"144","desc":"134"},{"messageId":"129","fix":"145","desc":"131"},{"messageId":"132","fix":"146","desc":"134"},{"messageId":"129","fix":"147","desc":"131"},{"messageId":"132","fix":"148","desc":"134"},{"messageId":"129","fix":"149","desc":"131"},{"messageId":"132","fix":"150","desc":"134"},{"messageId":"129","fix":"151","desc":"131"},{"messageId":"132","fix":"152","desc":"134"},{"messageId":"129","fix":"153","desc":"131"},{"messageId":"132","fix":"154","desc":"134"},"suggestUnknown",{"range":"155","text":"156"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"155","text":"157"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"158","text":"156"},{"range":"158","text":"157"},{"range":"159","text":"156"},{"range":"159","text":"157"},{"range":"160","text":"156"},{"range":"160","text":"157"},{"range":"161","text":"156"},{"range":"161","text":"157"},{"range":"162","text":"156"},{"range":"162","text":"157"},{"range":"163","text":"156"},{"range":"163","text":"157"},{"range":"164","text":"156"},{"range":"164","text":"157"},{"range":"165","text":"156"},{"range":"165","text":"157"},{"range":"166","text":"156"},{"range":"166","text":"157"},{"range":"167","text":"156"},{"range":"167","text":"157"},[422,425],"unknown","never",[558,561],[1818,1821],[431,434],[1632,1635],[442,445],[970,973],[1196,1199],[380,383],[496,499],[1841,1844]]